 def full_domain_of_peak(self, energy_center_of_the_peak):
        """Find the energy domain of a peak in a spectrum.

          The function get a point on the peak, and then from the point E take a spectrum slice to the higher(lower)
          energy in the size of the detector resolution, i.e the spectrum in (E, E+resolution).
          if the slice is not relatively constant, we move to the next slice - (E+energy_bin, E+energy_bin+resolution).
          if the slice is relatively constant, or has the opposite sign from the slope of than the slice have reached
          the end of the spectrum.

         Note: It is noticeable that the higher energy side of the peak is much less noisy
            than lower energy side, so the user should expect that.
         Warning: The function keeps searching for the peak domain until either the peak ends or the spectrum ends.
         For spectra generated from a Gaussian, the function may search the entire spectrum, making the function
         even more time-intensive.

         Parameters:
         - energy_in_the_peak (float): The energy around which to find the peak domain.
         - detector_energy_resolution (float, optional): The resolution of the detector. Default is 1.

         Returns:
         - tuple: A tuple containing the left and right boundaries of the identified peak domain.
         """
        spectrum = self.spectrum.xr_spectrum()
        peak_energy_res = self.spectrum.fwhm_calibration(energy_center_of_the_peak)
        start_of_energy_slice = energy_center_of_the_peak
        fit_params = lmfit.Parameters()
        energy_step_size = spectrum['energy'].values[1] - spectrum['energy'].values[0]

        flag = True
        # the while keeps on until the peak is over or the spectrum is over
        while flag and start_of_energy_slice > spectrum['energy'].values[1]:
            spectrum_slice = spectrum.sel(energy=slice(start_of_energy_slice - 3 * peak_energy_res,
                                                       start_of_energy_slice))
            fit_params.add('a', value=1.0)
            fit_params.add('b', value=0.0)
            result = lmfit.minimize(residual_std_weight, fit_params,
                                    args=(spectrum_slice['energy'].values, spectrum_slice.values))
            flag = not ((result.params['a'].value <= 0) or (result.params['a'].value - result.params['a'].stderr <= 0))
            start_of_energy_slice = start_of_energy_slice - energy_step_size
        left_energy_peak_domain = start_of_energy_slice

        fit_params = lmfit.Parameters()
        fit_params.add('a', value=1.0)
        fit_params.add('b', value=0.0)
        flag = True
        start_of_energy_slice = energy_center_of_the_peak
        while flag and start_of_energy_slice < spectrum['energy'].values[len(spectrum['energy'].values) - 2]:
            spectrum_slice = spectrum.sel(energy=slice(start_of_energy_slice,
                                                       start_of_energy_slice + 3 * peak_energy_res))
            fit_params.add('a', value=1.0)
            fit_params.add('b', value=0.0)
            result = lmfit.minimize(residual_std_weight, fit_params,
                                    args=(spectrum_slice['energy'].values, spectrum_slice.values))
            flag = not ((result.params['a'].value >= 0) or (result.params['a'].value - result.params['a'].stderr >= 0))
            start_of_energy_slice = start_of_energy_slice + energy_step_size
        right_energy_peak_domain = start_of_energy_slice
        return left_energy_peak_domain, right_energy_peak_domain


           def find_all_peaks(self, stat_error=0.05, fwhm_tol_min=0.5):
        """Find the peaks center and properties  in spectrum (preferably gamma spectrum) using scipy find_peaks
         and then calculate the domain of the peak using self.peak_domain.
        Note, scipy does return the domain of the peak, However, it doesn't
        seem to fit to our needs because the results are noisy and unreliable.
        TODO: i think two stages of peak analysis is better than one.
        I can check both.
        Fisrt i want to try using two stages of srarch such that numpy will search for all the relevant peaks.
        This can give first elimination for the peak search.
        Than, i'll dp an signal to noise ration for each peak that it found.
        Than we compare this two stage to one stage where in one stage we do only the signal to noise ratio.
        this may give better results than the standatt method because scipy is not very picky...
        Parameters:
        - stat_error - acceptable relative error in the total counts in the peak
        default: 0.05
        - fwhm_tol: tolerance of the fwhm how much can the peaks deviate from the original fwhm fit
        the deviation is only upward for cases of folding
        I don't think i actually need that in this structure, i hope to find a way to kick this factor out

        Returns:
        - tuple
        peaks_centers, properties.
        properties include the fwhm of the peaks and the left and right edges of the fwhm for the plotter

        """
        peaks_energy = []
        peaks_fwhm = []
        peaks_left_ips = []
        peaks_right_ips = []
        fwhm = self.spectrum.fwhm_calibration
        minimal_peak_area = 1 / stat_error ** 2

        # This assuming that the width is small compared with the second derivative of the calibration
        channel_fwhm = [fwhm(self.spectrum.energy_calibration(x)) /
                        self.spectrum.energy_calibration[1] for x in self.spectrum.channels]
        minimal_prominence = np.array([minimal_peak_area /
                                       (0.761438079 * np.sqrt(2 * np.pi) * (
                                               channel_fwhm[i] / (2 * np.sqrt(2 * np.log(2))))
                                        ) for i, x in enumerate(self.spectrum.channels)])
        minimal_fwhm = np.array([fwhm(x) * fwhm_tol_min for x in self.spectrum.channels])
        # finding peaks in numpy method which takes only the peaks with
        peaks, properties = find_peaks(self.spectrum.counts,
                                       prominence=minimal_prominence,
                                       width=minimal_fwhm,
                                       rel_height=0.5)
        peaks_energy = [self.spectrum.energy_calibration(peak) for peak in peaks]
        for i, width in enumerate(properties['widths']):
            peaks_left_ips.append(self.spectrum.energy_calibration(peaks[i] - width / 2))
            peaks_right_ips.append(self.spectrum.energy_calibration(peaks[i] + width / 2))
            peaks_fwhm.append(peaks_right_ips[-1] - peaks_left_ips[-1])

        properties['widths'] = peaks_fwhm
        properties['fwhm'] = properties.pop('widths')
        properties['fwhm_heights'] = properties.pop('width_heights')
        properties["right_ips"] = self.spectrum.energy_calibration(properties["right_ips"])
        properties["left_ips"] = self.spectrum.energy_calibration(properties["left_ips"])
        properties.pop('left_bases')
        properties.pop('right_bases')
        return peaks_energy, properties



    def peak_domain(self, peak_center, channel_mode=False):
        """ find a peak domain using the convoluted spectrum with the kernel
        Note this function works specifically for the second derivative of gaussian
        Parameters:
        - peak_center: float/integer
            estimated peak center or channel in channel mode
        - channel_model: bool
            to activate channel mode or note
        Returns:
        list
            list of touples of the domains
        """
        channels = self.spectrum.channels

        index_peak_center = np.where(channels > peak_center)[0][0] if channel_mode else (
            np.where(self.spectrum.xr_spectrum()['energy'] > peak_center))[0][0]
        # convolution derivative has 0 value in the peak edges
        conv_dv = self.kernel_convolution[1:] - self.kernel_convolution[:-1]
        # the behavior of the convoluted function derivative is -
        # ...minus,minus,0,plus, plus,...plus,plus,center(0 value),minus,minus,...,minus,minus,0,plus,plus...
        # the rest of this function use this to find the zero crossing in which
        # find the right edge
        flag1 = True
        flag2 = True
        right_side = conv_dv[index_peak_center:]
        index = -1
        while flag2:
            index = index + 1
            if right_side[index] < 0:
                flag2 = False
                while flag1:
                    index = index + 1
                    if right_side[index] > 0:
                        flag1 = False
        right_boundary = index_peak_center + index
        # find the left edge
        flag1 = True
        flag2 = True
        left_side = conv_dv[:index_peak_center]
        # In the right side, we start one index away from the center
        index = -1
        while flag2:
            index = index - 1
            if left_side[index] > 0:
                flag2 = False
                while flag1:
                    index = index - 1
                    if left_side[index] < 0:
                        flag1 = False

        left_boundary = index_peak_center + index
        # note that because of the derivative of the convolution the index is off by 1
        mode = self.spectrum.energy_calibration if not channel_mode else np.poly1d([1, 0])
        return mode(left_boundary + 1), mode(right_boundary + 1)


        # NEED TO DELETE SOME METHODS, THE FIT METHOD CAN HAVE ONE FUNCTION WITH THREE OUTPUTS
import xarray as xr
import numpy as np
import math
from uncertainties import ufloat, nominal_value, std_dev
from pyspectrum.peak_identification.peak_fit_functions import fit_gaussian


class Peak:
    """
        Represents a peak with methods for 1D peak gaussian fit, center calculation and so on...

        Attributes:
        - counts per channel (xarray.DataArray): counts per channel for all the peak.
           Methods:

    - `__init__(self, xarray.DataArray)`:
      Constructor method to initialize a Peak instance.

    - `peak_gaussian_fit_parameters(self, energy_in_the_peak, resolution_estimation=1, background_subtraction=False)`:
      Fit a Gaussian function to a peak in the spectrum and return fit parameters.

    - `peak_fwhm_fit_method(self, energy_in_the_peak, resolution_estimation=1, background_subtraction=False)`:
      Calculate the Full Width at Half Maximum (FWHM) of a peak in the spectrum using peak_gaussian_fit_parameters.

    - `peak_amplitude_fit_method(self, energy_in_the_peak, resolution_estimation=1, background_subtraction=False)`:
      Calculate the amplitude of a peak in the spectrum using peak_gaussian_fit_parameters.

    - `peak_center_fit_method(self, energy_in_the_peak, resolution_estimation=1, background_subtraction=False)`:
      Calculate the center (mean) of a peak in the spectrum using peak_gaussian_fit_parameters.

    - `peak_energy_center_first_moment_method(self, energy_in_the_peak, detector_energy_resolution=1,
                                              background_subtraction=False)`:
      Calculate the center (mean) of a peak using the first moment method.

    - `counts_in_fwhm_sum_method(self, energy_in_the_peak, detector_energy_resolution=1)`:
      Calculate the sum of counts within the Full Width at Half Maximum (FWHM) of a peak.

    - `counts_in_fwhm_fit_method(self, energy_in_the_peak, detector_energy_resolution=1)`:
      Calculate the sum of counts within the FWHM using a fit-based method.

    - 'subtract_background(self):
        subtract background from the peak
        """

    # Constructor method
    def __init__(self, peak_xarray: xr.DataArray, ufloat_count_left=None, ufloat_count_right=None):
        """ Constructor of Spectrum.

        Parameters:
        - counts per channel (xarray.DataArray): counts per channel for all the peak.
        """
        # Instance variables
        if not (isinstance(peak_xarray, xr.DataArray)) and len(peak_xarray.dims) == 1:
            raise TypeError("Variable peak_xarray must be of type 1d xr.DataArray.")
        self.peak = peak_xarray.rename({peak_xarray.dims[0]: 'channel'})
        self.estimated_center, self.estimated_resolution = self.center_fwhm_estimator()
        if ufloat_count_left is None:
            channel_min = self.peak.coords['channel'][0]
            left_side = self.peak.sel(channel=slice(channel_min, channel_min + self.estimated_resolution))
            self.height_left = ufloat(left_side.mean(), left_side.std())
        else:
            if not (isinstance(ufloat_count_left, type(ufloat(0, 0)))):
                raise TypeError("Variable ufloat_count_left must be of type ufloat.")
            self.height_left = ufloat_count_left
        if ufloat_count_right is None:
            channel_max = self.peak.coords['channel'][-1]
            right_side = self.peak.sel(channel=slice(channel_max - self.estimated_resolution, channel_max))
            self.height_left = ufloat(right_side.mean(), right_side.std())
        else:
            if not (isinstance(ufloat_count_right, type(ufloat(0, 0)))):
                raise TypeError("Variable height_right must be of type ufloat.")
            self.height_right = ufloat_count_right

    def center_fwhm_estimator(self):
        """ calculate the center of the peak
        the function operate by the following order -
         calculate the peak domain,
          find maximal value
          define domain within fwhm edges
          calculate the mean energy which is the center of the peak (like center of mass)
          """
        peak = self.peak
        maximal_count = peak.max()
        # Calculate the half-maximum count
        half_max_count = maximal_count / 2

        # Find the energy values at which the counts are closest to half-maximum on each side
        minimal_channel = peak.where(peak >= half_max_count, drop=True)['channel'].to_numpy()[0]
        maximal_channel = peak.where(peak >= half_max_count, drop=True)['channel'].to_numpy()[-1]
        # define the full width half maximum area (meaning the area which is bounded by the fwhm edges)
        fwhm_slice = peak.sel(channel=slice(minimal_channel, maximal_channel))
        # return the mean energy in the fwhm which is the energy center
        return (fwhm_slice * fwhm_slice.coords['channel']).sum() / fwhm_slice.sum(), (maximal_channel - minimal_channel)

    def peak_with_errors(self):
        """Return Peak. peak in ufloat for each count, the errors are in (counts)**0.5 format
        Returns:
        - xr.DataArray: Xarray representation of the spectrum with ufloat as values.
        """
        counts_with_error = [ufloat(count, abs(count) ** 0.5) for count in self.peak.values]
        return xr.DataArray(counts_with_error, coords=self.peak.coords, dims=['channel'])

    def sum_method_counts_under_fwhm(self):
        """Calculate the sum of counts within the Full Width at Half Maximum (FWHM) of a peak.

        The function operates by the following steps:
        1. Calculate the FWHM of the specified peak using the `peak_fwhm_fit_method`.
        2. Estimate the center of the peak using the `peak_energy_center_first_moment_method`.
        3. Define the energy domain within the FWHM edges.
        4. Slice the spectrum to obtain the counts within the FWHM domain.
        5. Return the sum of counts within the FWHM and its associated uncertainty.

        Parameters:
        - energy_in_the_peak (float): The energy around which to calculate the FWHM and sum counts.
        - detector_energy_resolution (float, optional): The resolution of the detector. Default is 1.

        Returns:
        - ufloat: A ufloat containing the sum of counts within the FWHM and its associated uncertainty.
          The uncertainty is calculated using uncertainties package

        Note: The function assumes background subtraction is performed during FWHM calculation.
        """
        # Calculate the peak domain and slice the peak

        fwhm, _ = self.fit_method_fwhm(background_subtraction=True)
        peak_center, _ = self.first_moment_method_center(background_subtraction=True)
        minimal_channel = peak_center - fwhm / 2
        maximal_channel = peak_center + fwhm / 2
        energy = self.peak.coords['channel']
        center_index = np.where(energy > peak_center)[0][0]
        de = energy[center_index+1] - energy[center_index]
        fwhm_slice = (
            self.subtract_background(with_errors=True)).sel(channel=slice(minimal_channel-de/2, maximal_channel))
        # return counts under fwhm
        return fwhm_slice.sum()

    def gaussian_fit_parameters(self, background_subtraction=True):
        """Fit a Gaussian function to a peak in the spectrum and return fit parameters.

        The function fits a Gaussian function to the specified peak in the spectrum. The peak's location and
        resolution are estimated, and if background_subtraction is enabled, background subtraction is performed
        before the fitting process.

        Parameters:
        - energy_in_the_peak (float): The energy in the peak which to fit the Gaussian peak.
        - resolution_estimation (float, optional): The estimated resolution of the peak (not of the detector,
        for example in doppler broadening.) Default is 1.
        - background_subtraction (bool, optional): If True, subtract background before fitting. Default is False.

        Returns:
        - tuple: A tuple containing the fit parameters and covariance matrix of the Gaussian fit.
        The fit parameters include:
        - Amplitude: Amplitude of the Gaussian peak.
        - Center: Center (mean) of the Gaussian peak.
        - FWHM: Full Width at Half Maximum of the Gaussian peak.

        The covariance matrix provides the uncertainties in the fit parameters.
        """
        if background_subtraction:
            peak = self.subtract_background(with_errors=True)
        else:
            peak = self.peak_with_errors()

        fit_params, cov = fit_gaussian(peak.rename({'channel': 'x'}),
                                       self.estimated_center,
                                       self.estimated_resolution)
        return fit_params, cov

    def fit_method_fwhm(self, background_subtraction=False):
        """ Calculate the Full Width at Half Maximum (FWHM) of a peak in the spectrum.

       The function estimates the FWHM of the specified peak by fitting a Gaussian function to it.
       If background_subtraction is enabled, background subtraction is performed before the fitting process.

       Parameters:
       - resolution_estimation (float, optional): The estimated resolution of the peak. Default is 1.
       - background_subtraction (bool, optional): If True, subtract background before fitting. Default is False.

       Returns:
       - tuple: A tuple containing the FWHM and its associated uncertainty.
       The uncertainty is calculated considering the covariance matrix obtained from the Gaussian fit.
       the uncertainty given regard the covariance of the other fit parameters up to one std in them.

       Note: The function assumes the output of `peak_gaussian_fit_parameters` is used for fitting.
       """
        fit_params, cov = self.gaussian_fit_parameters(background_subtraction)
        fwhm = fit_params[2]
        fwhm_error = (cov[2, 2] ** 0.5 +
                      (cov[1, 1] ** 0.5 / fit_params[1]) * np.abs(cov[2, 1]) ** 0.5 +
                      (cov[0, 0] ** 0.5 / fit_params[0]) * np.abs(cov[2, 0]) ** 0.5)
        return fwhm, fwhm_error

    def fit_method_amplitude(self, background_subtraction=False):
        """Calculate the amplitude of a peak in the spectrum.

        The function estimates the amplitude of the specified peak by fitting a Gaussian function to it.
        If background_subtraction is enabled, background subtraction is performed before the fitting process.

        Parameters:
        - energy_in_the_peak (float): The energy around which to calculate the peak amplitude.
        - resolution_estimation (float, optional): The estimated resolution of the peak. Default is 1.
        - background_subtraction (bool, optional): If True, subtract background before fitting. Default is False.

        Returns:
        - tuple: A tuple containing the peak amplitude and its associated uncertainty.
          The uncertainty is calculated considering the covariance matrix obtained from the Gaussian fit,
          accounting for the covariance of the other fit parameters up to one standard deviation in them.

        Note: The function assumes the output of `peak_gaussian_fit_parameters` is used for fitting.
        """
        fit_params, cov = self.gaussian_fit_parameters(background_subtraction)
        amplitude = fit_params[0]
        amplitude_error = (cov[0, 0] ** 0.5 +
                           (cov[1, 1] ** 0.5 / fit_params[1]) * np.abs(cov[0, 1]) ** 0.5 +
                           (cov[2, 2] ** 0.5 / fit_params[2]) * np.abs(cov[0, 2]) ** 0.5)
        return amplitude, amplitude_error

    def fit_method_center(self, background_subtraction=False):
        """Calculate the center (mean) of a peak in the spectrum.

        The function estimates the center of the specified peak by fitting a Gaussian function to it.
        If background_subtraction is enabled, background subtraction is performed before the fitting process.

        Parameters:
        - energy_in_the_peak (float): The energy around which to calculate the peak center.
        - resolution_estimation (float, optional): The estimated resolution of the peak. Default is 1.
        - background_subtraction (bool, optional): If True, subtract background before fitting. Default is False.

        Returns:
        - tuple: A tuple containing the peak center and its associated uncertainty.
          The uncertainty is calculated considering the covariance matrix obtained from the Gaussian fit,
          accounting for the covariance of the other fit parameters up to one standard deviation in them.

        Note: The function assumes the output of `peak_gaussian_fit_parameters` is used for fitting.
        """
        fit_params, cov = self.gaussian_fit_parameters(background_subtraction)
        center = fit_params[1]
        center_error = (cov[1, 1] ** 0.5 +
                        (cov[0, 0] ** 0.5 / fit_params[0]) * np.abs(cov[1, 0]) ** 0.5 +
                        (cov[2, 2] ** 0.5 / fit_params[2]) * np.abs(cov[1, 2]) ** 0.5)
        return center, center_error

    def fit_method_counts_under_fwhm(self):
        """Calculate the sum of counts within the Full Width at Half Maximum (FWHM) of a peak.

        The function operates by the following steps:
        1. Estimate the amplitude of the specified peak using the `peak_amplitude_fit_method`.
        2. Estimate the FWHM of the specified peak using the `peak_fwhm_fit_method`.
        3. using the formula for the counts to return the counts number
        the formula is  0.761438079*A*np.sqrt(2 *pi)*(fwhm/(2*np.sqrt(2*np.log(2))))* 1/bin_energy_size
        where
        - 0.761438079 the area under the fwhm of a standard gaussian A*exp(-x**2/sigma)
        - A gaussian amplitude
        - np.sqrt(2 *pi)*(fwhm/(2*np.sqrt(2*np.log(2)))) amplitude correction (change of variable)
        - 1/bin_energy_size change of variable (The amplitude depends on the bin width)

        Parameters:
        - energy_in_the_peak (float): The energy around which to calculate the FWHM and sum counts.
        - detector_energy_resolution (float, optional): The resolution of the detector. Default is 1.

        Returns:
        - tuple: A tuple containing the sum of counts within the FWHM and its associated uncertainty.
          The uncertainty is calculated considering the covariance matrix obtained from the Gaussian fit,
          accounting for the covariance of the other fit parameters up to one standard deviation in them.

        Note: The function assumes background subtraction is performed during FWHM calculation.
        """
        # Calculate the peak amplitude and fwhm
        amplitude, amplitude_error = self.fit_method_amplitude(background_subtraction=True)
        fwhm, _ = self.fit_method_fwhm(background_subtraction=True)
        # energy size of each bin
        bin_size = self.peak.coords['channel'][1] - self.peak.coords['channel'][0]
        # factor to get area under the fwhm
        factor_of_area = 0.76096811 * np.sqrt(2 * np.pi) * (fwhm / (2 * np.sqrt(2 * np.log(2))))
        return ufloat(factor_of_area * amplitude * (1 / bin_size), factor_of_area * amplitude_error * (1 / bin_size))

    def first_moment_method_center(self, background_subtraction=False):
        """Calculate the center (mean) of a peak in the spectrum.

        The function estimates the center of the specified peak by finding the full width half maximum domain and
        that it use the mean on the spectrum slice to calculate the peak center .
        If background_subtraction is enabled, background subtraction is performed before the fitting process.

        Parameters:
        - energy_in_the_peak (float): The energy around which to calculate the peak center.
        - detector_energy_resolution (float, optional): The energy resolution of the peak. Default is 1.
        - background_subtraction (bool, optional): If True, subtract background before fitting. Default is False.

        Returns:
        - ufloat: A ufloat containing the peak center and its associated uncertainty.
          The uncertainty is calculated using uncertainties package

        Note: The function assumes the output of `peak_gaussian_fit_parameters` is used for fitting.
        """
        # Calculate the peak domain and slice the peak
        fit_params, cov = self.gaussian_fit_parameters(background_subtraction)
        fwhm = fit_params[2]
        fwhm_error = (cov[2, 2] ** 0.5 +
                      (cov[1, 1] ** 0.5 / fit_params[1]) * np.abs(cov[2, 1]) ** 0.5 +
                      (cov[0, 0] ** 0.5 / fit_params[0]) * np.abs(cov[2, 0]) ** 0.5)
        gaussian_center = fit_params[1]
        gaussian_center_error = (cov[1, 1] ** 0.5 +
                                 (cov[2, 2] ** 0.5 / fit_params[1]) * np.abs(cov[1, 2]) ** 0.5 +
                                 (cov[0, 0] ** 0.5 / fit_params[0]) * np.abs(cov[1, 0]) ** 0.5)
        if not (math.isnan(fwhm_error) or math.isnan(gaussian_center_error)):
            minimal_channel = max(gaussian_center - gaussian_center_error - fwhm - fwhm_error,
                                  self.peak.coords['channel'][0])
            maximal_channel = min(gaussian_center + gaussian_center_error + fwhm + fwhm_error,
                                  self.peak.coords['channel'][-1])
            fwhm_slice = (self.peak_with_errors()).sel(channel=slice(minimal_channel, maximal_channel))
        else:
            minimal_channel = max(gaussian_center - fwhm,
                                  self.peak.coords['channel'][0])
            maximal_channel = min(gaussian_center + fwhm,
                                  self.peak.coords['channel'][-1])
            fwhm_slice = (self.peak_with_errors()).sel(channel=slice(minimal_channel, maximal_channel))
        # return the mean energy in the fwhm which is the energy center
        center = (fwhm_slice * fwhm_slice.coords['channel']).sum() / fwhm_slice.sum()
        return nominal_value(center.values.item()), std_dev(center.values.item())

    def subtract_background(self, with_errors=False):
        """ create a subtracted background pyspectrum from the xarray pyspectrum
        the method of the subtraction is as follows -
         - find the peak domain and the mean count in the edges
        - calculated erf according to the edges
        - subtract edges from pyspectrum  """
        if not with_errors:
            peak = self.peak
            height_left = nominal_value(self.height_left)
            height_right = nominal_value(self.height_right)
        else:
            peak = self.peak_with_errors()
            height_left = self.height_left
            height_right = self.height_right
        # define new coordinates in resolution units (for the error function to be defined correctly)
        peak = peak.assign_coords(channel=(peak.coords['channel'] - self.estimated_center) / self.estimated_resolution)
        # define error function on the domain
        erf_background = np.array([(math.erf(-x) + 1) for x in peak.coords['channel'].to_numpy()])
        # subtraction
        peak_no_bg = (peak - 0.5 * (height_left - height_right) * erf_background - height_right)
        # return the peak with the original coordinates
        return peak_no_bg.assign_coords(channel=self.peak.coords['channel'])
